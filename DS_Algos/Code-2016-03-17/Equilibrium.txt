Problem ->
The problem description is very short:
The equilibrium index of a sequence is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes. For example, in a sequence A:
A[0]=-7 A[1]=1 A[2]=5 A[3]=2 A[4]=-4 A[5]=3 A[6]=0
3 is an equilibrium index, because:
A[0]+A[1]+A[2]=A[4]+A[5]+A[6]
6 is also an equilibrium index, because:
A[0]+A[1]+A[2]+A[3]+A[4]+A[5]=0
(The sum of zero elements is zero) 7 is not an equilibrium index - because it is not a valid index of sequence A. If you still have doubts, here is a precise definition: The integer k is an equilibrium index of a sequence A[0],A[1]..,A[n-1] if and only if 0<= k and sum(A[0..(k-1)])=sum(A[(k+1)..(n-1)]). Assume the sum of zero elements is equal to zero. 

Write a function
int equi(int A[], int n)
that, given a sequence, returns its equilibrium index (any) or -1 if no equilibrium index exists. Assume that the sequence may be very long.

===============================================================

Solution 



#include<stdio.h>
#include<stdlib.h>

int equi(int A[], int N)
{


/*
    int m, lsum, rsum;
    
    for(i = o; i < n; ++i){

       lsum = rsum = 0;
 
       for(m = 0; m < k; ++m){
         lsum += A[i];
       }
       for(m = k; m < n; ++m){
          rsum += A[i];
       }
    }
*/

   if( N == 0)
     return -1;
 
  long long sum, sum_left, sum_right;

   int i;
   sum = sum_left = sum_right = 0; 
  
   for(i = 0; i < n; ++i){
     sum += (long long) A[i];
   }

   for(i = 0; i < n; ++i){
      sum_right = sum - sum_left - (long long) A[i];

      if(sum_left == sum_right)
          return i;
      sum_left += (long long) A[i];     
   }  

   return -1;
}


int main(void)
{
  int N, ret;   
  
  printf("\n Enter the Size of Array");
  scanf("%d",&N);

  int A[N];

  ret = equi(A, N);

  printf("%d",ret);
  
  return 0;
}