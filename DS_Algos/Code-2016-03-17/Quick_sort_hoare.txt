// Tony Hoare Algorithm


#include <stdio.h>

#include<stdlib.h>

#include<math.h>

#include<string.h>

#include<assert.h>



void swap(int *ptr_1, int a, int b)
{
     
   int temp;
    
   temp = ptr_1[a];
 
   ptr_1[a] = ptr_1[b];
 
   ptr_1[b] = temp;

}



//Choosing a random pivot minimizes the chance that you will encounter worst-case O(n2) performance

//(always choosing first or last would cause worst-case performance for nearly-sorted or nearly-reverse-sorted data).

//Choosing the middle element would also be acceptable in the majority of cases



int choose_Pivot(int l, int h)
{
 
    int pi = (l + rand() % (h - l + 1));    
   
    return pi;

}



// In Partition step

// 1.> Choose pivot

// 2.> Swap value of pivot with hi

// 3.> Store value of low in store_Index variable

// 4.> Take a loop from lo to hi

//      a.> if( current elememt is smaller than pivot)

//      b.> swap(current element with store_Index)

//      c.> Increment store_index

//    5.> swap(store_index and hi)
  
 
 
int partition(int *ar, int lo, int hi)
{

    int pivot_Index = choose_Pivot(lo, hi);

    int store_Index, i;
    

    swap(ar, pivot_Index, hi);

    store_Index = lo;

    for(i = lo; i < hi; i++)
    {

        if(ar[i] < ar[pivot_Index])
        {

            swap(ar, i, store_Index);
    
            store_Index++;

        }
    
   }

   swap(ar, store_Index, hi);

} 




void quick_Sort(int *ptr, int lo, int hi)

{

    if(lo < hi)
    {

        int pi = partition(ptr, lo, hi);
     
        quick_Sort(ptr, lo, pi);
    
        quick_Sort(ptr, pi+1, hi);
  
        }
  
}



int main()

{
     int arr[] = {3, 7, 8, 5, 2, 1, 9, 5, 4};
  
     int i;
  
 
    quick_Sort(arr, 0, 8);
    

    // print the Array
 
    for(i = 0; i < 9; i++)
    {
   
        printf("%d\t", arr[i]);
   
    }

 
    return 0;

}
