On a+ve integer you can perform 

Memoization (Recursion) Top Down Approach

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <cstring>
#include <algorithm>

using namespace std;
#define MAX 100

int memo[MAX + 1];

int memoFunc(int n)
{
   if(n == 1)
      return 0;
   else if(memo[n] != -1)
      return memo[n];
   int r = 1 + memoFunc(n-1);
   if(n % 2 == 0) {
       r = min(r, 1 + memoFunc(n/2));
   }
   if(n%3 == 0) {
       r = min(r, 1 + memoFunc(n/3) );
   }
   memo[n] = r;
       
   return r;    
}

int main() {
	// your code goes here
   
   int n = 10;
   
   fill_n(memo, MAX, -1);
  // cin >> n;
   
   int no_of_steps = memoFunc(n);
	
   cout << no_of_steps << "\n";
   
   for(int i = 0; i <= n; i++) {
       cout << memo[i] <<" ";
   }
   
	return 0;
}


========================================================================
Dynamic Programming (Bottom Up)

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <cstring>
#include <algorithm>

using namespace std;
#define MAX 100



int memoFunc(int n)
{
   int dp[n + 1], i;
   dp[1] = 0;
   
   for(i = 2; i <= n; i++) {
       dp[i] = 1 + dp[i-1];
       if(i%2 == 0){
           dp[i] = min(dp[i], 1 + dp[i/2]);
       }
       if(i % 3 == 0){
           dp[i] = min(dp[i], 1 + dp[i/3]);
       }
   }

   return dp[n];    
}

int main() {
	// your code goes here
   
   int n = 10;
   
   
   int no_of_steps = memoFunc(n);
	
   cout << no_of_steps << "\n";
   
   
   
	return 0;
}
